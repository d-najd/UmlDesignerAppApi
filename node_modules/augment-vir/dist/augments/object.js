"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyThroughJson = exports.mapObject = exports.areJsonEqual = exports.getEntriesSortedByKey = exports.isObject = exports.typedHasOwnProperties = exports.typedHasOwnProperty = exports.getObjectTypedValues = exports.getObjectTypedKeys = exports.filterToEnumValues = exports.isEnumValue = exports.getEnumTypedValues = exports.getEnumTypedKeys = void 0;
function getEnumTypedKeys(input) {
    // keys are always strings
    return getObjectTypedKeys(input).filter((key) => isNaN(Number(key)));
}
exports.getEnumTypedKeys = getEnumTypedKeys;
function getEnumTypedValues(input) {
    const keys = getEnumTypedKeys(input);
    return keys.map((key) => input[key]);
}
exports.getEnumTypedValues = getEnumTypedValues;
function isEnumValue(input, checkEnum) {
    return getEnumTypedValues(checkEnum).includes(input);
}
exports.isEnumValue = isEnumValue;
function filterToEnumValues(inputs, checkEnum, caseInsensitive = false) {
    if (caseInsensitive) {
        return inputs.reduce((accum, currentInput) => {
            const matchedEnumValue = getEnumTypedValues(checkEnum).find((actualEnumValue) => {
                return String(actualEnumValue).toUpperCase() === String(currentInput).toUpperCase();
            });
            if (matchedEnumValue) {
                return accum.concat(matchedEnumValue);
            }
            else {
                return accum;
            }
        }, []);
    }
    else {
        return inputs.filter((input) => isEnumValue(input, checkEnum));
    }
}
exports.filterToEnumValues = filterToEnumValues;
function getObjectTypedKeys(input) {
    return Object.keys(input);
}
exports.getObjectTypedKeys = getObjectTypedKeys;
function getObjectTypedValues(input) {
    return Object.values(input);
}
exports.getObjectTypedValues = getObjectTypedValues;
function typedHasOwnProperty(inputKey, inputObject) {
    return (typeof inputObject === 'object' &&
        inputObject &&
        Object.prototype.hasOwnProperty.call(inputObject, inputKey));
}
exports.typedHasOwnProperty = typedHasOwnProperty;
function typedHasOwnProperties(inputKeys, inputObject) {
    return (typeof inputObject === 'object' &&
        inputObject &&
        inputKeys.every((key) => Object.prototype.hasOwnProperty.call(inputObject, key)));
}
exports.typedHasOwnProperties = typedHasOwnProperties;
function isObject(input) {
    return typeof input === 'object' && !!input;
}
exports.isObject = isObject;
function getEntriesSortedByKey(input) {
    return Object.entries(input).sort((tupleA, tupleB) => tupleA[0].localeCompare(tupleB[0]));
}
exports.getEntriesSortedByKey = getEntriesSortedByKey;
function areJsonEqual(a, b) {
    try {
        const sortedAEntries = getEntriesSortedByKey(a);
        const sortedBEntries = getEntriesSortedByKey(b);
        return JSON.stringify(sortedAEntries) === JSON.stringify(sortedBEntries);
    }
    catch (error) {
        console.error(`Failed to compare objects using JSON.stringify`);
        throw error;
    }
}
exports.areJsonEqual = areJsonEqual;
/**
 * Creates a new object with the same properties as the input object, but with values set to the
 * result of mapCallback for each property.
 */
function mapObject(inputObject, mapCallback) {
    let gotAPromise = false;
    const mappedObject = getObjectTypedKeys(inputObject).reduce((accum, currentKey) => {
        const mappedValue = mapCallback(currentKey, inputObject[currentKey]);
        if (mappedValue instanceof Promise) {
            gotAPromise = true;
        }
        return {
            ...accum,
            [currentKey]: mappedValue,
        };
    }, {});
    if (gotAPromise) {
        return new Promise(async (resolve, reject) => {
            try {
                await Promise.all(getObjectTypedKeys(mappedObject).map(async (key) => {
                    const value = await mappedObject[key];
                    mappedObject[key] = value;
                }));
                resolve(mappedObject);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    else {
        return mappedObject;
    }
}
exports.mapObject = mapObject;
/** The input here must be serializable otherwise JSON parsing errors will be thrown */
function copyThroughJson(input) {
    try {
        return JSON.parse(JSON.stringify(input));
    }
    catch (error) {
        console.error(`Failed to JSON copy for`, input);
        throw error;
    }
}
exports.copyThroughJson = copyThroughJson;
