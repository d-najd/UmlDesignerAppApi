/// <reference types="node" />
import { ChildProcess } from 'child_process';
import { EventEmitter } from 'stream';
export declare type ShellOutput = {
    error: undefined | Error;
    stderr: string;
    stdout: string;
    exitCode: number | undefined;
    exitSignal: NodeJS.Signals | undefined;
};
export declare const ShellEmitterEvent: {
    readonly stdout: "stdout";
    readonly stderr: "stderr";
    readonly done: "done";
    readonly error: "error";
};
export declare type ShellEmitterEventKey = typeof ShellEmitterEvent[keyof typeof ShellEmitterEvent];
export declare type ShellEmitterListenerMap = {
    [ShellEmitterEvent.stdout]: [string | Buffer];
    [ShellEmitterEvent.stderr]: [string | Buffer];
    /**
     * Exit code and exit signal. Based on the Node.js documentation, either one or the other is
     * defined, never both at the same time.
     */
    [ShellEmitterEvent.done]: [
        exitCode: number | undefined,
        exitSignal: NodeJS.Signals | undefined
    ];
    [ShellEmitterEvent.error]: [Error];
};
export interface ShellEmitter extends EventEmitter {
    emit<T extends ShellEmitterEventKey>(type: T, ...args: ShellEmitterListenerMap[T]): boolean;
    on<T extends ShellEmitterEventKey>(type: T, listener: (...args: ShellEmitterListenerMap[T]) => void): this;
    addListener<T extends ShellEmitterEventKey>(type: T, listener: (...args: ShellEmitterListenerMap[T]) => void): this;
    once<T extends ShellEmitterEventKey>(type: T, listener: (...args: ShellEmitterListenerMap[T]) => void): this;
    removeListener<T extends ShellEmitterEventKey>(type: T, listener: (...args: ShellEmitterListenerMap[T]) => void): this;
    off<T extends ShellEmitterEventKey>(type: T, listener: (...args: ShellEmitterListenerMap[T]) => void): this;
    childProcess: ChildProcess;
}
export declare function streamShellCommand(command: string, cwd?: string, shell?: string, env?: NodeJS.ProcessEnv): ShellEmitter;
export declare type RunShellCommandParams = {
    cwd?: string | undefined;
    env?: NodeJS.ProcessEnv | undefined;
    shell?: string | undefined;
    /** Automatically hook up stdout and stderr printing to the caller's console methods. */
    hookUpToConsole?: boolean | undefined;
    rejectOnError?: boolean | undefined;
    stdoutCallback?: (stdout: string) => void | Promise<void> | undefined;
    stderrCallback?: (stderr: string) => void | Promise<void> | undefined;
};
export declare function runShellCommand(command: string, options?: RunShellCommandParams): Promise<ShellOutput>;
export declare function printShellCommandOutput(ShellOutput: {
    error?: unknown;
    stderr?: unknown;
    stdout?: unknown;
    exitCode?: unknown;
}, withLabels?: boolean, ignoreError?: boolean): void;
