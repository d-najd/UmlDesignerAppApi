"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printShellCommandOutput = exports.runShellCommand = exports.streamShellCommand = exports.ShellEmitterEvent = void 0;
const child_process_1 = require("child_process");
const stream_1 = require("stream");
const error_1 = require("../error");
exports.ShellEmitterEvent = {
    stdout: 'stdout',
    stderr: 'stderr',
    done: 'done',
    error: 'error',
};
function streamShellCommand(command, cwd, shell = 'bash', env = process.env) {
    const shellEmitter = new stream_1.EventEmitter();
    const childProcess = (0, child_process_1.spawn)(command, { shell, cwd, env });
    shellEmitter.childProcess = childProcess;
    if (!childProcess.stdout) {
        throw new Error(`stdout emitter was not created by exec for some reason.`);
    }
    if (!childProcess.stderr) {
        throw new Error(`stderr emitter was not created by exec for some reason.`);
    }
    childProcess.stdout.on('data', (chunk) => {
        shellEmitter.emit(exports.ShellEmitterEvent.stdout, chunk);
    });
    childProcess.stderr.on('data', (chunk) => {
        shellEmitter.emit(exports.ShellEmitterEvent.stderr, chunk);
    });
    childProcess.on('error', (processError) => {
        shellEmitter.emit(exports.ShellEmitterEvent.error, processError);
    });
    /**
     * Based on the Node.js documentation, we should listen to "close" instead of "exit" because the
     * io streams will be finished when "close" emits. Also "close" always emits after "exit" anyway.
     */
    childProcess.on('close', (inputExitCode, inputExitSignal) => {
        const exitCode = inputExitCode ?? undefined;
        const exitSignal = inputExitSignal ?? undefined;
        if ((exitCode !== undefined && exitCode !== 0) || exitSignal !== undefined) {
            const execException = new Error(`Command failed: ${command}`);
            execException.code = exitCode;
            execException.signal = exitSignal;
            execException.cmd = command;
            execException.killed = childProcess.killed;
            execException.cwd = cwd;
            shellEmitter.emit(exports.ShellEmitterEvent.error, execException);
        }
        shellEmitter.emit(exports.ShellEmitterEvent.done, exitCode, exitSignal);
    });
    // Might need to add a "disconnect" listener here as well. I'm not sure what it should do yet.
    // Like, should it emit "done"? idk.
    return shellEmitter;
}
exports.streamShellCommand = streamShellCommand;
/** Helper function just to help with generics. */
function processListener(eventType, eventListener) {
    return { eventType, eventListener };
}
function prepareChunkForLogging(chunk, trimEndingLine) {
    const stringified = chunk.toString();
    return trimEndingLine ? stringified.replace(/\n$/, '') : stringified;
}
async function runShellCommand(command, options = {}) {
    return new Promise((resolve, reject) => {
        let stdout = '';
        let stderr = '';
        const errors = [];
        const shellStream = streamShellCommand(command, options.cwd, options.shell, options.env);
        const listeners = [
            processListener(exports.ShellEmitterEvent.stdout, (chunk) => {
                if (options.stdoutCallback) {
                    options.stdoutCallback(prepareChunkForLogging(chunk, false));
                }
                if (options.hookUpToConsole) {
                    console.log(prepareChunkForLogging(chunk, true));
                }
                stdout += chunk;
            }),
            processListener(exports.ShellEmitterEvent.stderr, (chunk) => {
                if (options.stderrCallback) {
                    options.stderrCallback(prepareChunkForLogging(chunk, false));
                }
                if (options.hookUpToConsole) {
                    console.error(prepareChunkForLogging(chunk, true));
                }
                stderr += chunk;
            }),
            processListener(exports.ShellEmitterEvent.error, (executionError) => {
                errors.push(executionError);
                if (options.rejectOnError) {
                    listeners.forEach((listener) => shellStream.removeListener(listener.eventType, listener.eventListener));
                    if (shellStream.childProcess.connected) {
                        shellStream.childProcess.disconnect();
                    }
                    if (shellStream.childProcess.exitCode == null &&
                        shellStream.childProcess.signalCode == null &&
                        !shellStream.childProcess.killed) {
                        shellStream.childProcess.kill();
                    }
                    const rejectionErrorMessage = (0, error_1.combineErrorMessages)([
                        ...errors,
                        stderr,
                    ]);
                    // reject now cause the "done" listener won't get fired after killing the process
                    reject(new Error(rejectionErrorMessage));
                }
            }),
            processListener(exports.ShellEmitterEvent.done, (exitCode, exitSignal) => {
                resolve({
                    error: (0, error_1.combineErrors)(errors),
                    stdout,
                    stderr,
                    exitCode,
                    exitSignal,
                });
            }),
        ];
        listeners.forEach((listener) => {
            shellStream.addListener(listener.eventType, listener.eventListener);
        });
    });
}
exports.runShellCommand = runShellCommand;
function printShellCommandOutput(ShellOutput, withLabels = false, ignoreError = false) {
    if (ShellOutput.exitCode != undefined || withLabels) {
        withLabels && console.info('exit code');
        console.info(ShellOutput.exitCode);
    }
    if (!!ShellOutput.stdout || withLabels) {
        withLabels && console.info('stdout');
        console.info(ShellOutput.stdout);
    }
    if (!!ShellOutput.stderr || withLabels) {
        withLabels && console.info('stderr');
        console.error(ShellOutput.stderr);
    }
    if (ShellOutput.error || withLabels) {
        withLabels && console.info('error');
        if (!ignoreError) {
            throw ShellOutput.error;
        }
    }
}
exports.printShellCommandOutput = printShellCommandOutput;
