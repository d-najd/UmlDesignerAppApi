"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeferredPromiseWrapper = exports.wrapPromiseInTimeout = exports.PromiseTimeoutError = exports.wait = void 0;
function wait(delayMs) {
    const deferredPromiseWrapper = createDeferredPromiseWrapper();
    if (delayMs === Infinity || delayMs < 0) {
        return deferredPromiseWrapper.promise;
    }
    setTimeout(() => {
        deferredPromiseWrapper.resolve();
    }, delayMs);
    return deferredPromiseWrapper.promise;
}
exports.wait = wait;
class PromiseTimeoutError extends Error {
    durationMs;
    message;
    name = 'PromiseTimeoutError';
    constructor(durationMs, message = `Promised timed out after ${durationMs} ms.`) {
        super(message);
        this.durationMs = durationMs;
        this.message = message;
    }
}
exports.PromiseTimeoutError = PromiseTimeoutError;
function wrapPromiseInTimeout(durationMs, originalPromise) {
    return new Promise(async (resolve, reject) => {
        const timeoutId = setTimeout(() => {
            reject(new PromiseTimeoutError(durationMs));
        }, durationMs);
        try {
            const result = await originalPromise;
            resolve(result);
        }
        catch (error) {
            reject(error);
        }
        finally {
            clearTimeout(timeoutId);
        }
    });
}
exports.wrapPromiseInTimeout = wrapPromiseInTimeout;
function createDeferredPromiseWrapper() {
    let resolve;
    let reject;
    const promise = new Promise((resolveCallback, rejectCallback) => {
        resolve = resolveCallback;
        reject = rejectCallback;
    });
    if (!resolve || !reject) {
        throw new Error(`Reject and resolve callbacks were not set by the promise constructor for ${createDeferredPromiseWrapper.name}.`);
    }
    return {
        promise,
        resolve,
        reject,
    };
}
exports.createDeferredPromiseWrapper = createDeferredPromiseWrapper;
